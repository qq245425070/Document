###### 红黑树的删除操作

◆ 说明  
T.nil 也是黑色的；  
“黑色节点”，如果N节点被删除了，根节点经过N节点的路径，黑高变小了，那么该节点称为“双黑节点”；  
远侄子：双黑节点是左节点，其兄弟节点的又孩子，是其远侄子；  
近侄子：双黑节点是右节点，其兄弟节点的左孩子，是其近侄子；
首次锁定到的被删除节点，是被删除节点；  
非首次锁定的被删除节点，是N节点；  
非首次锁定的被删除节点，本身有颜色，被锁定之后，会再添加一次黑色，所以有 红+黑，和 黑+黑 的节点；  

假如某个T.nil 被标记为N节点，做旋转时，有个节点Y，旋转到这个N节点的位置，  
则 Y就是新的N节点，Y的颜色加上黑色，就是N节点的新颜色；

被删除节点，右子树，最小节点代替被删除节点：  
● 被删除节点是黑色的，最小节点是黑色的，新的N节点，在最小节点位置；  
● 被删除节点是黑色的，最小节点是红色的，新的N节点，在被删除节点的位置；  
● 被删除节点是红色的，最小节点是红色的，算法结束；  
● 被删除节点是红色的，最小节点是黑色的，新的N节点，在最小节点位置；  

◆ 继续判断   
N 指向 红+黑 的节点，N设为黑色的，算法结束；  
N 指向 黑+黑 的节点，且N是根节点，算法结束；  
N 指向 黑+黑 的节点，且N不是根节点，继续判断；  

◆ 标记N节点  
（1.1）被删除节点，只有一个子节点，或者子节点都是T.nil节点；    
♬ 操作步骤：  
右子T.nil节点 或者其子节点，替换 被删除节点，标记为 N 节点；  
♬ 继续判断；  
（1.2）被删除节点，有两个子节点；  
♬ 操作步骤：  
找到，被删除节点，右子树中，最小节点；  
最小节点代替 被删除节点；  
♬ 继续判断；  
（1.3）N 是 红+黑 节点；  
N节点，的兄弟节点，是红色的；  
N节点，设为红色的；  
♬ 算法结束；    
（2.1）N 是 黑+黑 节点；     
N节点，兄弟节点，是黑色的；  
N节点，左侄子是红色的，右侄子是红色的；  
♬ 操作步骤：  
N节点，的父节点的颜色，赋值给兄弟节点；  
N节点，的父节点，设为黑色的；      
N节点，的左侄子节点设为黑色的；  
N节点，的父节点为旋转点，做右旋转；  
N节点，标记为根节点；  
♬ 算法结束；  
（2.2）N 是 黑+黑 节点；  
N节点，兄弟节点，是黑色的；  
N节点，左侄子是黑色的，右侄子是黑色的；  
操作步骤：    
被删除节点，兄弟节点，设为红色；  
被删除节点，父节点，被当做最新 被删除节点；  
继续判断；  
（2.3.1）N 是 黑+黑 节点；    
N节点，是右节点；    
N节点，兄弟节点，是黑色的；    
N节点，左侄子是红色的，右侄子是黑色的；    
N节点，左侄子是红色的，右侄子是红色的；    
♬ 操作步骤：    
N节点，的父节点的颜色，赋值给兄弟节点；  
N节点，的父节点，设为黑色的；      
N节点，的左侄子节点设为黑色的；    
N节点，的父节点为旋转点，做右旋转；    
♬ 继续判断；     
 （2.3.2）N 是 黑+黑 节点；    
N节点，是左节点；    
N节点，兄弟节点，是黑色的；    
N节点，左侄子是红色的，右侄子是黑色的；    
N节点，左侄子是红色的，右侄子是红色的；    
♬ 操作步骤：    
N节点，的兄弟节点，设为红色的；      
N节点，的左侄子节点设为黑色的；   
N节点，的兄弟节点为旋转点，做右旋转；   
♬ 继续判断；   
（2.4.1）N 是 黑+黑 节点；    
N节点，兄弟节点，是黑色的；  
N节点，N是左节点；    
N节点，左侄子是黑色的，右侄子是红色的；     
♬ 操作步骤：        
被删除节点，的父节点的颜色，赋值给 被删除节点的 兄弟节点；    
被删除节点，的父节点设为黑色的；   
被删除节点，的右侄子设为黑色的；  
被删除节点，的父节点作为旋转点，做左旋转；     
♬ 继续判断；    
（2.4.2）N 是 黑+黑 节点；    
N节点，兄弟节点，是黑色的；    
N节点，N是右节点；    
N节点，左侄子是黑色的，右侄子是红色的；    
♬ 操作步骤：      
被删除节点，的兄弟节点设为红色的；    
被删除节点，的右侄子设为黑色的；  
被删除节点，的兄弟节点作为旋转点，做左旋转；     
♬ 继续判断；    
