非递归, 打印二叉树上, 根节点到叶子节点的路径, 所有路径全打印;  
非递归, 打印二叉树上, 根节点到目标节点的路径;  
二叉树, 给定目标节点, 旋转节点, 使期作为根节点;  
二叉树旋转, 离找到根节点最近的任意一个叶子节点;  

有一个十互不相同的数字组成的数组，现在需要取两个数相加等于50的所有组合，请设计一个算法;  


### 数组  
数组, 奇数在左, 偶数在右;  
[链接](segment01/a004.md)  

一组数字, 只有一个是单独出现, 其他的都是成对出现, 找出单独出现的数字  
[链接](segment01/a009.md)  

一个递增数组, 折半查找, 目标数字可能有2个, 找出第一个的下标  
[链接](segment01/a006.md)  

1,2,3,4,5,6,7,8,9;  在一个递增无重复数组, 找出第一个 大于等于 target 的数;  
[链接](segment01/a007.md)  

1,2,3,4,5,6,7,8,9;  一组递增无重复数组, 找出最接近 target 的数;  
[链接](segment01/a010.md)  

在一个递增无重复数组和一个目标值, 在数组中找到目标值, 并返回其索引, 如果目标值不存在于数组中, 返回它将会被按顺序插入的位置;  
[链接](segment01/a011.md)  

给定一个非负整数 numRows, 生成杨辉三角的前 numRows 行  
[链接](segment01/a012.md)  

给定一个排序数组, 你需要在原地删除重复出现的元素, 使得每个元素只出现一次, 返回移除后数组的新长度;  
[链接](segment01/a014.md)  

数组中出现次数超过一半的数  
https://www.cnblogs.com/neuzk/p/9487463.html  

从1亿个数里面找出前100个最大的  
https://www.cnblogs.com/neuzk/p/9487757.html  

### 链表  
单链表翻转;  双向链表翻转;  
[链接](segment01/a008.md)  

两个链表, 相交, 找到第一个相交的节点;  
[链接](segment01/a013.md)  

https://www.cnblogs.com/neuzk/p/9503173.html  
https://www.cnblogs.com/ttltry-air/archive/2012/08/14/2638284.html  
### 二叉树  
二叉树, 先序遍历-中序遍历-后序遍历-层序遍历, 非递归实现方式;  
[链接](segment01/a001.md)  

二叉树, 根节点到指定节点的路径;  
[链接](segment01/a016.md)

给定一个二叉树, 找到该树中两个指定节点的最近公共祖先;  
[链接](segment01/a015.md)  

给定一个二叉树, 打印所有的叶子节点;  
二叉树的深度优先遍历, 二叉树的广度优先遍历;  


https://www.cnblogs.com/neuzk/p/9504099.html   
https://www.cnblogs.com/neuzk/p/9486095.html  
### 树  
树, 深度优先-广度优先, 非递归实现方式;  
[链接](segment01/a002.md)  

###  字符串  
判断字符串是 ip4  
[链接](segment01/a003.md)  

字符串压缩;  aaabccdd = a4bc2d2  
[链接](segment01/a005.md)  



