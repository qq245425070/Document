### 锁  锁的概念  
锁的状态总共有四种: 无锁状态, 偏向锁, 轻量级锁, 重量级锁;  

★ 偏向锁:  
偏向锁的核心思想是, 如果一个线程获得了锁, 那么锁就进入偏向模式, 此时 Mark Word 的结构也变为偏向锁结构;  
当这个线程再次请求锁时, 无需再做任何同步操作, 即获取锁的过程, 这样就省去了大量有关锁申请的操作, 从而也提升了性能;  
所以, 对于没有锁竞争的场合, 偏向锁有很好的优化效果, 毕竟极有可能连续多次是同一个线程申请相同的锁;  
但是对于锁竞争比较激烈的场合, 偏向锁就失效了, 因为这样场合极有可能每次申请锁的线程都是不相同的;  
因此这种场合下不应该使用偏向锁, 否则会得不偿失, 需要注意的是, 偏向锁失败后, 并不会立即膨胀为重量级锁, 而是先升级为轻量级锁;  

判断是否为可偏向状态?  
偏向锁, 获取过程, 判断线程ID是否指向当前线程;  
是, 即表示这个偏向锁就是这个线程持有,  直接执行代码块;  
否, 通过 CAS 操作竞争锁;  
    竞争成功,  则设置线程 ID 为当前线程, 并执行代码块;  
    竞争失败, 说明多线程竞争啦, 问题严重了, 当偏向锁到达安全点时, 将偏向锁升级为轻量锁;  

偏向锁, 获取过程,         
当偏向锁遇到其他线程, 尝试竞争时, 持有偏向锁的线程会释放, 并升级为轻量锁;   
到达安全点, 暂停拥有偏向锁的线程, 判断锁对象是否处于被锁的状态, 撤销偏向锁后恢复到未锁定(标志位为“01”), 或轻量级锁(标志位为“00”)的状态;  

★ 轻量级锁:  
倘若偏向锁失败, 虚拟机并不会立即升级为重量级锁, 它还会尝试使用一种称为轻量级锁的优化手段(1.6之后加入的);  
此时 Mark Word 的结构也变为轻量级锁的结构;  轻量级锁能够提升程序性能的依据是 "对绝大部分的锁, 在整个同步周期内都不存在竞争", 注意这是经验数据;   
需要了解的是, 轻量级锁所适应的场景是线程交替执行同步块的场合, 如果存在同一时间访问同一锁的场合, 就会导致轻量级锁膨胀为重量级锁;  

自旋锁:  
轻量级锁失败后, 虚拟机为了避免线程真实地在操作系统层面挂起, 还会进行一项称为自旋锁的优化手段;  
这是基于在大多数情况下, 线程持有锁的时间都不会太长, 如果直接挂起操作系统层面的线程可能会得不偿失, 毕竟操作系统实现线程之间的切换时需要从用户态转换到核心态,  
这个状态之间的转换需要相对比较长的时间, 时间成本相对较高, 因此自旋锁, 会假设, 在不久将来, 当前的线程可以获得锁,   
因此虚拟机会让当前想要获取锁的线程做几个空循环(这也是称为自旋的原因), 一般不会太久, 可能是50个循环或100循环,   
在经过若干次循环后, 如果得到锁, 就顺利进入临界区;  
如果还不能获得锁, 那就会将线程在操作系统层面挂起, 这就是自旋锁的优化方式, 这种方式确实也是可以提升效率的;  
最后没办法也就只能升级为重量级锁了;  

锁消除:  
消除锁是虚拟机另外一种锁的优化, 这种优化更彻底, Java虚拟机在JIT编译时(可以简单理解为当某段代码即将第一次被执行时进行编译, 又称即时编译);  
通过对运行上下文的扫描, 去除不可能存在共享资源竞争的锁, 通过这种方式消除没有必要的锁, 可以节省毫无意义的请求锁时间;  
如下 StringBuffer的 append 是一个同步方法, 但是在 add 方法中的 StringBuffer 属于一个局部变量, 并且不会被其他线程所使用;  
因此 StringBuffer 不可能存在共享资源竞争的情景, JVM会自动将其锁消除;  

### 总结  
简单来讲, 单线程时, 使用偏向锁;  
如果这个时候, 又来了一个线程访问这个代码块, 那么就要升级为轻量锁;  
如果这个线程在访问代码块同时, 又来了一个线程来访问这个代码块, 那么就要升级为重量锁了;  


### 参考  
https://blogs.oracle.com/dave/biased-locking-in-hotspot  
