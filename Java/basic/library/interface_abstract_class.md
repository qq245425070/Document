###  Java 接口 和 抽象类

抽象类的几个特点   
1.. 包含抽象方法的类称为抽象类, 它同样可以拥有成员变量和普通的成员方法;  
2.. 如果一个非抽象类继承了抽象类, 则非抽象类必须实现抽象父类的 所有抽象方法;  
3.. 子类中的抽象方法不能与父类的抽象方法同名;  
4.. 抽象类不能创建实体, 因为抽象类存在抽象方法, 而抽象方法没有实体, 创建对象后, 抽象对象调用抽象方法是没有意义的;  
5.. 抽象类中一定有构造函数。主要为了初始化抽象类中的属性。通常由子类实现;  
6.. final 和 abstract 是否可以同时修饰一个方法, 因为用final修饰后,  修饰 类 代表不可以继承 ,  修饰 方法 不可重写,    
abstract 修饰类就是用来被继承的, 修饰方法就是用来被重写的;  

接口  
接口是对行为的抽象, 而没有具体的实现;  
1.. 接口中的所有方法的访问权限只能为public;  
2.. 接口中的所有变量只能是 public static final 的, 即接口中只能声明静态常量;  
3.. 接口中的方法不能有方法体;  
4.. 接口中的方法默认都是抽象的, 所以接口不能被实例化;  
5.. 接口是没有构造方法的;  

抽象类和接口 在 语法层面上的区别  
抽象类有普通方法, 而接口中只能有抽象方法;   
抽象类中的成员可以是常量, 也可以是变量, 而接口中的成员常量;  
抽象类可以有构造方法, 接口没有;  
抽象类的方法修饰符 可以有多种, 接口只有public 方法;  
接口中不能含有静态代码块以及静态方法, 而抽象类可以有静态代码块和静态方法;  
一个类只能继承一个抽象类, 而一个类却可以实现多个接口,  因为Java是单继承, 多实现 ;  

抽象类和接口 在 设计层面上的区别  
抽象类是对类的整体进行抽象, 包括属性、行为;接口是对类局部（行为）的抽象。  
抽象类所体现的是一种继承关系, 而继承是一个 “is-a”的关系, 而 接口 实现则是 “has-a”的关系。  
抽象类作为很多子类的父类, 它是一种模板式设计;而接口是一种行为规范, 它是一种辐射式设计;  
对于抽象类, 如果需要添加新的方法, 可以直接在抽象类中添加具体的实现, 子类可以不进行变更;  
而对于接口则不行, 如果接口进行了变更, 则所有实现这个接口的类都必须进行相应的改动。


### 对Java中面向对象的认识
抽象  
把现实生活某一类东西提取出来, 成为该类东西的共有特性。  
抽象一般分为数据抽象和过程抽象, 数据抽象是对象的属性, 过程抽象是对象的行为特征  

封装  
封装是将 一些列数据 和 操作 组合在一起, 构成一个不可分割的实体。  
数据被保护在抽象数据类型的内部, 尽可能地隐藏内部的细节, 只保留一些对外接口使之与外部发生联系,   外部并不知道对象内部的细节（当然也无从知道）;

封装的好处
1.. 良好的封装能够减少耦合;  
2.. 类内部的结构可以自由修改;    
3.. 可以对成员进行更精确的控制;    
4.. 隐藏信息, 实现细节;  

继承  
从已有的类中派生出新的类, 新的类能吸收已有类的数据属性和行为, 并能扩展新的能力; 
继承的好处   
通过使用继承我们能够非常方便地复用以前的代码, 能够大大的提高开发的效率。

多态  
同一个行为具有多个不同表现形式的能力, 多态的前提是类与类之间必须存在关系, 要么继承, 要么实现;  
怎么实现多态？  
1.. 接口实现;  
2.. 继承父类重写方法;  
3.. 同一类中进行方法重载;  

多态的好处：    
1.. 多态对已存在代码具有可替换性;  
2.. 增加新的子类不影响已经存在的类结构;  
3.. 多态是超类通过方法签名, 想子类提供一个公共接口,由子类来完善或者重写它来实现的;  


重写与重载  
重写, 是覆盖父类方法的具体实现;  
重载, 是一组方法名称完全一致, 入参类型 或者 入参个数不一样的 一些列方法实现;

### Java类的各种成员初始化顺序  
Java类的各种成员初始化顺序如: 父子类继承时的静态代码块,普通代码块,静态方法,构造方法,等先后顺序;  

1.. 父类 (静态属性) 和 (静态代码块), 按在代码中出现的顺序依次执行;  
2.. 子类 (静态属性) 和 (静态代码块), 按在代码中出现的顺序依次执行;  

3.. 父类 (普通成员变量被普通成员方法赋值) 和 (普通代码块), 按在代码中出现的顺序依次执行;  
4.. 执行父类的构造方法;  

5.. 子类 (普通成员变量被普通成员方法赋值) 和 (普通代码块), 按在代码中出现的顺序依次执行;  
6.. 执行子类的构造方法;  

