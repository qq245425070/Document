### Class 类文件结构  
魔数, Class 文件版本, 常量池, 访问标志, 类索引-父类索引与接口索引集合, 字段表集合, 方法表集合, 属性表集合;  
Class 文件是一组, 以一个字节(8 位)为基础单位的二进制流, 各个数据项目严格按照顺序紧凑地排列在 Class 文件之中, 中间没有添加任何分隔符,  
当遇到需要占用 8 位字节以上空间的数据项时, 则会按照高位在前的方式分割成若干个 8 位字节进行存储;  
根据 Java 虚拟机规范的规定, Class 文件格式采用一种类似于 C 语言结构体的伪结构来存储数据, 这种伪结构中只有两种数据类型: 无符号数和表;  

魔数与 Class 文件版本  
每个 Class 文件的头 4 个字节称为魔数(Magic Number), 它的唯一作用是确定这个文件是否为一个能被虚拟机接受的 Class 文件;  
很多文件存储标准中都使用魔数来进行身份识别, 譬如图片格式, 如 gif 或者 jpeg 等在文件头中都存有魔数;  
使用魔数而不是扩展名来进行识别, 主要是基于安全方面的考虑, 因为文件扩展名可以随意地改动;  
文件格式的制定者可以自由地选择魔数值, 只要这个魔数值还没有被广泛采用过同时又不会引起混淆即可;  
紧接着魔数的 4 个字节存储的是 Class 文件的版本号,  高版本的 JDK 能向下兼容以前版本的 Class 文件, 但不能运行以后版本的 Class 文件;  

常量池  
在 Class 文件版本号之后, 是常量池, 常量池可以理解为 Class 文件中的资源仓库, 常量池中的常量的数量不固定, 但是常量池入口会声明常量的数量;  
常量池中主要存放两大类常量: 字面量(Literal), 和符号引用(Symbolic References);  
字面量比较接近于 Java 语言层面的常量概念, 如文本字符串,  声明为 final 的常量值等;  
符号引用则属于编译原理方面的概念, 包括了下面三类常量:  
类和接口的全限定名(Fully Qualified Name);  
字段的名称和描述符(Descriptor);  
方法的名称和描述符(Descriptor);  
Java 代码子进行编译的时候, 并不是会像 C++ 那样有'连接'这一步, 而是在虚拟机加载 Class 文件的时候进行动态连接;  
也就是说, Class 文件不会保存方法和字段的最终内存信息, 当虚拟机运行时, 需要从常量池中获取到符号引用, 在类创建或者运行时经过解析得到真正的内存地址;  


访问标志  
在常量池结束之后, 紧接着的两个字节代表访问标志(access_flags), 这个标志用于识别一些类或者接口层次的访问信息,  
包括: 这个 Class 是类还是接口, 是否定义为 public 类型, 是否定义为 abstract 类型, 如果是类的话, 是否被声明为 final 等;  

类索引, 父类索引与接口索引集合  
Class 文件中由这三项数据来确定这个类的继承关系; 类索引用于确定这个类的全限定名, 父类索引用于确定这个类的父类的全限定名;  
由于 Java 语言不允许多重继承, 所以父类索引只有一个;  
除了 java.lang.Object 之外, 所有的 Java 类都有父类;  
接口索引集合就用来描述这个类实现了哪些接口, 这些被实现的接口将按 implements 语句后的接口顺序, 从左到右排列在接口索引集合中;  

字段表集合  
字段表(field_info)用于描述接口或者类中声明的变量, 字段(field)包括类级变量以及实例级变量, 但不包括在方法内部声明的局部变量;  
字段信息包括: 作用域(private, public 等), 是否有 static 修饰, 是否有 final 修饰, 等等;  

方法表集合  
方法表的结构如同字段表一样, 依次包括了:  
访问标志(access_flags),  名称索引(name_index),  描述符索引(descriptor_index),  属性表集合(attributes)  

属性表集合  
Class 文件, 字段表, 方法表, 都可以携带自己的属性表集合;  
如果字段有额外信息, 会在 attributes 里面出现;  
1.. Code 属性  
Java 程序方法体中的代码, 经过 javac 编译之后, 最终会变成字节码指令, 存储在 attributes 的 Code 属性里面;  
2.. Exceptions 属性  
列举出方法中可能抛出受检异常, 也就是在 throws 之后列举出来的异常;  
3.. LineNumberTable 属性  
用于描述 java 源代行号与字节码行号之间的对应关系;  
它并不是运行时必须的属性, 但是默认情况下会生成到 class 文件中, 也可以在 javac 添加属性 -g:none 选项来取消这项信息;  
如果没有 LineNumberTable 并不会影响程序运行, 只是在产生异常时, 堆栈信息中并不会打印行号, 也无法进行断点调试;  
4.. LocalVariableTable 属性  
用于描栈帧中的, 局部变量表中的变量与 java 源码中定义的变量的关系;  
它也不是运行时必须的属性, 但是默认情况下会生成到 class 文件中, 也可以在 javac 添加属性 -g:none 选项来取消这项信息;  
如果没有这个属性, 并不会影响程序的运行, 只不过是方法的名称和参数的名称会丢失;  
5.. SourceFile 属性  
用于记录生成这个 class 文件的源文件的名称;  
它也不是运行时必须的属性, 但是默认情况下会生成到 class 文件中, 也可以在 javac 添加属性 -g:none 选项来取消这项信息;  
如果没有 SourceFile 属性并不会影响程序运行, 只是在产生异常时, 堆栈信息中并不会显示错误代码所属的源文件名称;  

### 参考  
http://www.it610.com/article/5901050.htm  
https://yq.aliyun.com/articles/663999  



