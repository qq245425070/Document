### JMM.基本概念  
JMM(Java Memory Model ,JMM)定义了线程和主存之间的抽象关系;  
屏蔽了各种硬件和操作系统的访问差异, 保证了 Java 程序在各种平台下对内存的访问的效果一致;   
目的是解决 CPU 多级缓存, 处理器优化, 指令重排等导致的内存访问问题, 保证了并发场景下的一致性, 原子性和有序性;  
目的是解决由于多线程通过共享内存进行通信时, 存在的本地内存数据不一致, 编译器会对代码指令重排序, 处理器会对代码乱序执行等带来的问题;   
Java 内存模型, 定义程序中各个变量的访问规则, 即在虚拟机中将变量存储到内存和从内存中取出变量这样的底层细节;   
Java 内存模型, 规定了所有的变量都存储在主内存中, 每条线程还有自己的工作内存, 线程的工作内存中保存了该线程中是用到的变量的主内存副本拷贝;  
线程对变量的所有操作都必须在工作内存中进行, 而不能直接读写主内存, 不同的线程之间也无法直接访问对方工作内存中的变量;  
线程间变量的传递均需要自己的工作内存和主存之间进行数据同步进行;   
此处的变量与 Java 变成中所说的变量是有所区别, 它包括了实例字段, 静态字段和构成数组对象的元素, 但不包括局部变量和方法参数;   

❀ JMM 结构 的介绍  
JVM 中存在一个主存(Main Memory 或 Java Heap Memory), Java 中所有的变量, 都会存在内存中, 对于所有线程进行共享,  
而每个线程有存在自己的, 工作内存(Working Memory), 工作内存中保存的是, 主存中某些变量的备份;  
线程对所有变量的操作, 并非发生在主存中, 而是发生在工作内存中, 线程之间不能直接访问工作内存, 变量在程序中的传递, 是依赖主存完成的;  
在当今多核处理器中, 大部分数据存储在, 高速缓存中;  
synchronized 和 volatile 关键字提供内存模型中的可见性, 是使用一些特殊指令来刷新缓存, 刷新硬件缓存, 延时执行功能操作, 无疑会对程序的性能, 产生一点的影响;  
![JMM 结构 的简单分析](ImageFiles/jmm_001.gif)  

为什么要有工作内存和主存  
工作内存用到的共享变量, 只是对主存的拷贝;  
工作内存对共享变量的修改, 只是少量的;  
工作内存所产生的变量, 大多数跟随线程的生命周期而销毁;  
工作内存对主存共享变量的修改, 需要特殊处理;  
大多数情况下, 线程之间的通信, 需要控制的变量, 不是很多;  
颗粒度更细致, 更方便管理;  

❀ 可见性(visibility)  
所有的变量, 都存储在主存中(虚拟机内存的一部分), 对于所有线程都是共享的;  
每条线程, 都有自己的工作内存, 工作内存中保存的, 是主存中某些变量的拷贝, 线程对变量的所有操作, 都是在工作内存中进行, 而不是直接读写主内存中的变量;  
JMM 在默认情况下, 不会处理各个线程对同一个内存区域的可见性, 因此需要去手动实现;  
JMM 内存模型里面, 并发线程修改全局变量的时候, 必须将变量同步到内存后, 其他线程才能正确访问到;  
 一旦某个字段, 被声明为 volatile, 任何写操作会, 立刻将其同步到主存, 而不是只缓存在工作内存中;  
通过 synchronized 和 Lock 也能够保证可见性, 同一时刻, 只有一个线程获取锁, 然后执行同步代码, 并且在释放锁之前, 会将对变量的修改刷新到主存当中;  

❀ 原子性  
什么是原子性?  
即一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断, 要么就都不执行;   
提供了两个高级的字节码指令 monitorenter 和 monitorexit, 保证了内存模型中的原子性;  
因此, 在 Java 中可以使用 synchronized 来保证方法和代码块内的操作是原子性的;  
[synchronized 详见](/Java/basic/concurrent/synchronized.md)   

JMM 规定的原子性有哪些?   
在 Java 中, 只有 对基础数据类型的变量 的 直接读写操作, 是 原子性操作;  
例如:  
int x, y;  
x = 10;  //语句 1  
y = x;  //语句 2  
x++;  //语句 3  
x = x+1;  //语句 4  
以上只有 语句 1  的操作时原子性的, 是属于对基础数据类型的 直接读写操作;  
语句 2  有两步操作:读取 x 数值, 写入 y 的数值;  
语句 3  有两步操作的, 读取 x 的数值, 写入新的数值;  
语句 4  有两步操作的, 读取 x 的数值, 写入新的数值;  

在 Java 中, JMM 保证的原子性操作, 范围非常小, 如果要实现更大范围的原子性操作, 可以通过 synchronized 或者 lock 来实现;  
由于 synchronized 和 lock 能够在保证在某一时刻, 只有一个线程执行该代码块, 故此操作不会出现并发修改的问题, 从而保证了原子性;   

❀ 有序性  
排序性主要围绕, 读写语句有关的序列, 如果在该模型内部使用了 "一致的同步性" 的时候, 这些属性都会遵循比较简单的原则:  
每个同步块内的任何变化都具备了原子性以及可见性, 每个同步块都有一个独立空间, 以及独立的同步控制器和锁机制;  
然后对外按照 JVM 的执行指令进行数据的读写操作, 使得使用内存的过程变得非常严谨;   
除了引入了时间片以外, 由于处理器优化和指令重排等, CPU还可能对输入代码进行乱序执行;  

❀ happens before  
在 JMM 中, 如果一个操作执行的结果需要对另一个操作可见, 那么这两个操作之间必须要存在 happens-before 关系;   
A happens before B 意思就是 B 要能访问到 A;  
happens-before 仅仅要求前一个操作(执行的结果)对后一个操作可见, 且前一个操作按顺序排在第二个操作之前;  

八种原子性操作:  
lock: 作用于主内存的变量, 把一个变量标识为一条线程独占的状态;  
unlock: 作用于主内存的变量, 把一个处于锁定状态的变量释放出来;  
read: 把一个变量的值从主内存传输到工作内存中, 以便随后的 load 使用;  
load: 把 read 操作从主内存中得到的变量值放入到工作内存的变量副本中;  
use: 把工作内存中一个变量的值传递给执行引擎, 每当虚拟机遇到一个需要使用变量的值的字节码指令时将会执行这个操作;  
assign: 把一个从执行引擎中接收到的值赋值给工作内存中的变量, 每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作;  
store: 把工作内存中的一个变量的值传递到主内存, 以便随后的 write 使用;  
write: 把 store 操作从工作内存中得到的变量值放入到主内存的变量中;  

### volatile 关键字
Java 语言是支持多线程的, 为了解决线程并发的问题, 在语言内部引入了同步块 和 volatile 关键字机制;  
Java 语言中的 volatile 变量可以被看作是一种 "程度较轻的 synchronized", 与 synchronized 块相比, volatile 变量所需的编码较少, 并且运行时开销也较少;   
但是它所能实现的功能也仅是 synchronized 的一部分;  

volatile 关键字的特点:  
1.. volatile 保证共享变量的可见性;  
当一个共享变量被 volatile 修饰时, 它会保证修改的值, 会立即从工作内存更新到主存, 当有其他线程需要读取时, 它会去内存中读取新值;  
而普通的共享变量不能保证可见性, 因为普通共享变量被修改之后, 什么时候被写入主存是不确定的;  
当其他线程去读取时, 此时内存中可能还是原来的旧值, 因此无法保证可见性;  
2.. volatile 变量, 禁止指令重排优化;  
3.. volatile 并不能保证操作的原子性;  
4.. 单独使用 volatile 还不足以实现计数器, 互斥锁;  

❀  指令排序  
指令排序, 是为了使处理器内部的运算器, 能够被充分利用, 处理器可能会对输入指令, 进行重排, 优化执行效率;  
不会对存在依赖关系的指令重排序;  
不能影响单线程下的执行结果;  
```
int a = 10;    // 语句1  
int r = 2;    // 语句2  
a = a + 3;    // 语句3  
r = a*a;     // 语句4  
```
这个时候会指令排序吗?  
当然不会了,  因为 他们有相互依赖的关系, 质量排序, 只是机器优化, 提高运行效率, 并不会改变其运行结果;  

在执行程序时, 为了提高性能, 编译器和运算器, 常常会对指令重新排序  
1.. 编译器优化的重排序;  
      编译器在不改变单线程程序语义的前提下, 可以重新安排语句的执行顺序;  
2.. 指令级并行的重排序;  
      现代处理器, 采用了指令级并行技术, 来将多条指令重叠执行;  
      如果不存在数据依赖性, 处理器可以改变语句对应机器指令的执行顺序;  
3.. 内存系统的重排序;  
      由于处理器使用缓存, 和读写缓冲区, 这使得加载和存储操作, 看上去可能是在乱序执行;  

深入理解JVM, 对指令排序的描述  
除了增加高速缓存之外, 为了使得处理器内部的运算单元能尽量被充分利用, 处理器可能会对输入代码进行乱序执行(Out-Of-Order Execution)优化,   
处理器会在计算之后将乱序执行的结果重组, 保证该结果与顺序执行的结果是一致的, 但并不保证程序中各个语句计算的先后顺序与输入代码中的顺序一致,   
因此, 如果存在一个计算任务依赖另外一个计算任务的中间结果, 那么其顺序性并不能靠代码的先后顺序来保证;   
与处理器的乱序执行优化类似, Java虚拟机的即时编译器中也有类似的指令重排序(Instruction Reorder)优化;  
![从源码到最终执行的指令序列的示意图](/Java/jvm/ImageFiles/jmm_002.png)  

❀ as-if-serial 语义  
不管怎么重排序(编译器和处理器为了提高并行度), (单线程)程序的执行结果不能被改变;  
编译器, runtime 和处理器都必须遵守 as-if-serial 语义;  
为了遵守 as-if-serial 语义, 编译器和处理器不会对存在数据依赖关系的操作做重排序, 因为这种重排序会改变执行结果;  
但是, 如果操作之间不存在数据依赖关系, 这些操作就可能被编译器和处理器重排序;  

要使 volatile 变量提供理想的线程安全, 必须同时满足下面两个条件:    
1.. 对变量的写操作不依赖于当前值;  
2.. 该变量没有包含在具有其他变量的不变式中;  

第一个条件的限制使 volatile 变量不能用作线程安全计数器;  
虽然增量操作(x++)看上去类似一个单独操作,   实际上它是一个由读取－修改－写入操作序列组成的组合操作,   
必须以原子方式执行, 而 volatile 不能提供必须的原子特性;实现正确的操作需要使 x 的值在操作期间保持不变, 而 volatile 变量无法实现这点;  
然而, 如果将值调整为只从单个线程写入, 那么可以忽略第一个条件;  
在目前大多数的处理器架构上, volatile 读操作开销非常低 —— 几乎和非 volatile 读操作一样,而 volatile 写操作的开销要比非 volatile 写操作多很多;   
因为要保证可见性需要实现内存界定(Memory Fence), 即便如此, volatile 的总开销仍然要比锁获取低;  
volatile 操作不会像锁一样造成阻塞, 因此, 在能够安全使用 volatile 的情况下, volatile 可以提供一些优于锁的可伸缩特性;  
如果读操作的次数要远远超过写操作, 与锁相比, volatile 变量通常能够减少同步的性能开销;  

[volatile 示例](/Java/jvm/volatile_sample.md)    
状态标志  
一次性安全发布   
### 参考  
http://www.cnblogs.com/BangQ/p/4045954.html  
https://github.com/LRH1993/android_interview/blob/master/java/concurrence/volatile.md  
http://www.hollischuang.com/archives/2550  
https://juejin.im/post/5cad4adc5188251b1f4d87d2  
https://juejin.im/post/5cad4adc5188251b1f4d87d2#heading-10  

volatile  
https://github.com/LRH1993/android_interview/blob/master/java/concurrence/volatile.md  
http://www.cnblogs.com/dolphin0520/p/3920373.html  
http://www.importnew.com/27002.html  
https://www.cnblogs.com/paddix/p/5428507.html  
https://juejin.im/post/59db333b6fb9a00a69752a39  
https://juejin.im/post/5b722dd4f265da27e6334924  
