### JVM怎么判断对象是否已死  

### 引用计数算法  
◆ 简单描述  
很多教科书判断对象是否存活的算法是这样的：给对象中添加一个引用计数器，  
每当有一个地方引用它时，计数器值就加1；当引用失效时，计数器值就减1；  
任何时刻计数器为0的对象就是不可能再被使用的。  

◆ 其bug  
客观地说，引用计数算法的实现简单，判定效率也很高，在大部分情况下它都是一个不错的算法。  
但是，至少主流的Java虚拟机里面没有选用引用计数算法来管理内存，  
其中最主要的原因是它很难解决对象之间相互循环引用的问题。  

举个简单的例子，对象objA和objB都有字段instance，赋值令objA.instance=objB及objB.instance=objA，  
除此之外，这两个对象再无任何引用，实际上这两个对象已经不可能再被访问，但是它们因为互相引用着对方，  
导致它们的引用计数都不为0，于是引用计数算法无法通知GC收集器回收它们。  

### 可达性分析算法  
通过一些列的称为“GC Roots”的对象作为起始点, 从这些节点开始向下搜索, 搜索所走过的路径称为引用链;  
当一个对象到 GC Roots 没有任何引用链相连时, 就是从GC Roots 到这个对象是不可达, 则证明此对象是不可用的, 所以它们会被判定为可回收对象;  

可以作为GC Roots的对象包括下面几种:  
由系统类加载器(system class loader), 加载的对象, 通过用户自定义的类加载器加载的类不是 GC Root;  
正在运行的方法, 方法中使用的对象;  
类的引用类型的, 静态变量;  
类中常量引用的对象;  
正在运行的 native 方法中使用的对象;  


★ 在可达性分析算法中, 要真正宣告一个对象死亡, 至少要经历两次标记过程:   
如果对象在进行可达性分析后, 发现没有与 GC Roots 相连接的引用链, 那它将会被第一次标记, 并且进行一次筛选, 筛选的条件是, 此对象是否有必要执行finalize()方法;  
当对象没有覆盖finalize()方法, 或者finalize()方法已经被虚拟机调用过, 虚拟机将这两种情况都视为“没有必要执行”, 标记可以被回收;  

如果这个对象被判定为, 有必要执行finalize()方法, 那么这个对象, 将会放置在一个叫做 F-Queue 队列之中;  
并在稍后, 由一个由虚拟机自动建立的, 低优先级的 Finalizer 线程去执行它;  
finalize()方法是对象逃脱死亡命运的最后一次机会, 稍候 GC 将对 F-Queue 中的对象, 进行第二次小规模的标记;  
如果对象要在finalize()中成功拯救自己, 只要重新与引用链上的任何一个对象建立关联即可;  
譬如把自己(this关键字), 赋值给某个类变量, 或者对象的成员变量, 那在第二次标记时, 它将会被移除出“即将回收”的集合;  
如果对象这时候还没有逃脱, 那基本上它就真的被回收了;  

#### 生存还是死亡 finalize  
即使在可达性分析算法中不可达的对象，也并非是“非死不可”的，这时候它们暂时处于“缓刑”阶段，  
要真正宣告一个对象死亡，至少要经历两次标记过程：  
如果对象在进行可达性分析后发现没有与GC Roots相连接的引用链，那它将会被第一次标记并且进行一次筛选，  
筛选的条件是此对象是否有必要执行finalize（）方法。   
♬ 当对象没有覆盖finalize（）方法，或者finalize（）方法已经被虚拟机调用过，虚拟机将这两种情况都视为“没有必要执行”。  
♬ 如果这个对象被判定为有必要执行finalize（）方法，那么这个对象将会放置在一个叫做F-Queue的队列之中，  
并在稍后由一个由虚拟机自动建立的、 低优先级的Finalizer线程去执行它。   
这里所谓的“执行”是指虚拟机会触发这个方法，但并不承诺会等待它运行结束，这样做的原因是，  
如果一个对象在finalize（）方法中执行缓慢，或者发生了死循环（更极端的情况），  
将很可能会导致F-Queue队列中其他对象永久处于等待，甚至导致整个内存回收系统崩溃。   
finalize（）方法是对象逃脱死亡命运的最后一次机会，稍后GC将对F-Queue中的对象进行第二次小规模的标记，  
如果对象要在finalize（）中成功拯救自己——只要重新与引用链上的任何一个对象建立关联即可，  
譬如把自己（this关键字）赋值给某个类变量或者对象的成员变量，那在第二次标记时它将被移除出“即将回收”的集合；  
如果对象这时候还没有逃脱，那基本上它就真的被回收了。   
另外一个值得注意的地方是，代码中有两段完全一样的代码片段，执行结果却是一次逃脱成功，一次失败，  
这是因为任何一个对象的finalize（）方法都只会被系统自动调用一次，如果对象面临下一次回收，它的finalize（）方法不会被再次执行，  
因此第二段代码的自救行动失败了。
需要特别说明的是，上面关于对象死亡时finalize（）方法的描述可能带有悲情的艺术色彩，笔者并不鼓励大家使用这种方法来拯救对象。   
相反，笔者建议大家尽量避免使用它，因为它不是C/C++中的析构函数，而是Java刚诞生时为了使C/C++程序员更容易接受它所做出的一个妥协。   
它的运行代价高昂，不确定性大，无法保证各个对象的调用顺序。 有些教材中描述它适合做“关闭外部资源”之类的工作，  
这完全是对这个方法用途的一种自我安慰。finalize（）能做的所有工作，使用try-finally或者其他方式都可以做得更好、 更及时，    

### 参考  
gcRoot  
https://www.yourkit.com/docs/java/help/gc_roots.jsp  
